# node.js

## 简介

运行在服务器上的js，用来编写服务器

特点 ：单线程，异步，非阻塞 ； 同一API

目前node的创始人因为node的缺点开始研究一门新的语言 ： Deno.js

nvm 命令

​	nvm list ：显示当前已经安装的node版本

​	nvm install 版本号/latest/lts ：安装指定版本/最新版本/最新稳定版本

​	nvm use 版本号/latest/lts ：使用指定版本/最新版本/最新稳定版本

​	镜像配置 ：nvm node_mirror https://npmmirror.com/mirrors/node/



node.js 和 javascript 的区别 ：

​	两者的基本规范都是ECMAscript ，但是 node 没有DOM、BOM。(但是有用的还是保留了)

## 异步编程

进程 ：一个程序运行的环境

线程 ： 一个程序实际完成运算的东西

同步 ：代码按照从上到下的顺序依次执行，当中途某段代码执行较慢或无法执行时，将会影响到整个程序的执行

​	会出现阻塞状态

解决方法 ：

​	Java、Python可以采用多线程的形式解决

​	node.js ： 采用异步形式解决

异步 ： 当一段代码执行较慢或无法执行时，并不会一直等待其执行完成，而是执行其他代码，并不会影响程序的执行

​	特点 ： 不会阻塞其他代码执行；需要通过回调函数来返回结果

​	问题 ： 异步无法通过return直接返回结果

 	基于回调函数实现的异步 ： 

​		1.代码可读性很差

​		2.可调试性差

​      所有的问题都是通过回调函数返回结果实现异步带来（Promis解决）

## Promise 

​	是一个用来存放数据的对象	

​	他的特殊的存储方法使得他可以存放异步调用的数据

​	用于解决回调函数实现异步时的会回调地狱

### 创建 

​	通过构造函数 new Promise() 创建一个Promise实例

​	必须为构造函数添加一个回调函数作为参数（通过这个回调函数的参数来存放异步数据）

​	回调函数参数 ： 一般写为 ： resolve 和reject。两个参数都是一个函数

​	resolve 将会在程序正常运行时向Promise存放数据，reject将会在程序出错时向Promise存放数据

### 读取 

​	实例方法 ：

​	then()

​		两个参数 ： 都是回调函数，第一个参数可以用于读取resolve存放的数据，可以写入处理正常运行数据的代码；第二个参数可以读取reject存放的数据或者代码异常数据，可以写入处理异常运行数据的代码

​	catch() :

​		一个参数（回调函数），会在读取reject存放或者代码出错时（即Promise被拒接时）执行

​		专门处理Promise异常

​		相当于then()，只不过第一个参数为null

​	finally() : 

​		无论是正常存储数据还是出现异常，finally都会执行

​		finally的回调函数中，不会接受存放在实例中的数据。

​		用于编写一些无论是否成功都要执行的代码

### 两个隐藏属性 

​	PromiseResult ：存放数据

​	PromsieState  ：描述Promise的三个状态

​			pending :（数据正在存储进行中）

​			fulfilled :  (完成) 通过resolve存放数据时

​			rejected : （拒绝，出错）通过reject存放数据时

​		PromiseState只允许修改一次，之后无法进行修改

### 执行流程

​	首先通过构造函数创建一个Promise实例，实例的PromiseState将会设置为pending

​	当使用resolve存放数据时，PromiseState将会被设置为fulfilled

​	当使用reject存放数据或者代码出错时，PromiseState将被设置为rejected

​	当调用实例方法then时，会根据PromiseState的状态进行调用回调函数，fulfilled将调用第一个回调函数，rejected将

会调用第二个回调函数

### 链式调用

​	基础 ：

​		then、catch、finally三个方法调用时，会返回一个新的Promise对象，并将返回值存放到新Promise对象中（finally并不会）。

​	省略 ：

​		在链式调用中，如果当前的then或catch在读取上一个Promsie的存放的数据时（正常返回或异常信息），如果没有成功读到，将会直接跳过这个读取，转而进行下一个读取。

​	catch读错 ：

​		在链式调用中，catch只会读取他之前的错误，他后面的错误包括他本身的错误是不在这个catch读取范围内的，只能通过后面的catch读取

### Promsie的静态方法 

​	Promise.resolve() : 创建一个立即完成的Promise ，参数就是存放数据

​		相当与 ： new Promise((resolve,reject) => { resolve() })

​	Promise.reject() : 创建一个立即拒接的Promise ，功能与Promise.resolve一致

​	Promise.all() ： 

​		参数是一个迭代器（数组...），会返回一个数组，里面存放了参数迭代器中所有的Promise的运行结果。

​		其中当有一个Promise 是拒接的，将会抛出错误，一错全没

​	Promise.allsettled() ：

​		参数是一个迭代器（数组...），会返回一个对象数组，无论是否成功，Promise的状态和执行结果都存放在对象汇总

​	Promise.race() ：

​		参数是一个迭代器（数组...），所有Promise会一起执行，并返回一个最快执行的Promise数据

​	Promise.any() ：

​		参数是一个迭代器（数组...），所有Promise会一起执行，并返回一个最快执行并完成的Promise数据

### async 和 await 

​	async  ：快速创建一个异步函数，函数返回一个Promsie	

​		通过async修饰的函数，将会自动变为异步函数，并将该函数的返回值封装到一个Promise中

​	await ： 

​		当通过await去调用异步函数时，会暂停代码的执行，等到异步代码执行完毕后，有结果后返回结果

​		只能使用在async创建的异步函数中或者在ES模块的顶级作用域中

​		await在调用异步代码时，使用try-catch 语句来处理错误信息

​		 当使用await 调用函数时，会将后续的代码在函数执行完毕后，放入微任务队列(一个await,就指将后面代码放入一个then中)   

​		 await 不会影响到异步函数外的代码，但会影响到异步函数中await代码的后面代码（但是后面的代码是必须需要这个结果的，所有对后续代码无影响）

## 模块化

​	当一个js文件中实现的功能较多，代码数量大时，会导致代码维护难度加大，通过将不同功能写在不同的js文件中，然后全部引进一个文件的模式较之前的维护难度上更加简单方便，称后面的方式为模块化

​	早期网页中，没有模块化的规范，往往通过script标签来引入多个js文件。

​	引入的js代码完成的功能并不是按需引用，存在大量不需要的功能。并且在复杂情况下，非常容易出错（顺序不同...导致错误）

### 	CommonJS 

​		是 node.js 默认支持的模块化规范 （早期官方并未给出规范，直到15年才出现,前面就是民间自创）

​		cjs 、默认js、默认json都属于CommonJs规范

​		引入 ：

​			require（"路径"） ： 函数来引入模块 （可以省略扩展名）

​			引入自定义模块 ：

​				使用相对路径 ，未写扩展名时，node会自动补充，会优先查找js文件 ，在查json

​			引入核心模块 ：  直接写核心模块的名字 或者 node：名字（速度快）	

​			 引入文件夹中的所有模块 : 

​				引入文件夹中的入口文件 : index.js(已经将其他模块放入在一起)

​				但单独引入文件夹时,会默认查找index.js文件

新知识

​	throw new Error() : 自定义一个异常情况，可以传递参数来当做异常信息

​	try-catch 语句 

​	

```
try {
	正常时执行这一部分内容
}catch(error) {
	错误时执行这一部分内容
	console.log(error);
}
```

