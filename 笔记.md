# node.js

## 简介

运行在服务器上的js，用来编写服务器

特点 ：单线程，异步，非阻塞 ； 同一API

目前node的创始人因为node的缺点开始研究一门新的语言 ： Deno.js

nvm 命令

​	nvm list ：显示当前已经安装的node版本

​	nvm install 版本号/latest/lts ：安装指定版本/最新版本/最新稳定版本

​	nvm use 版本号/latest/lts ：使用指定版本/最新版本/最新稳定版本

​	镜像配置 ：nvm node_mirror https://npmmirror.com/mirrors/node/



node.js 和 javascript 的区别 ：

​	两者的基本规范都是ECMAscript ，但是 node 没有DOM、BOM。(但是有用的还是保留了)

## 异步编程

进程 ：一个程序运行的环境

线程 ： 一个程序实际完成运算的东西

同步 ：代码按照从上到下的顺序依次执行，当中途某段代码执行较慢或无法执行时，将会影响到整个程序的执行

​	会出现阻塞状态

解决方法 ：

​	Java、Python可以采用多线程的形式解决

​	node.js ： 采用异步形式解决

异步 ： 当一段代码执行较慢或无法执行时，并不会一直等待其执行完成，而是执行其他代码，并不会影响程序的执行

​	特点 ： 不会阻塞其他代码执行；需要通过回调函数来返回结果

​	问题 ： 异步无法通过return直接返回结果

 	基于回调函数实现的异步 ： 

​		1.代码可读性很差

​		2.可调试性差

​      所有的问题都是通过回调函数返回结果实现异步带来（Promis解决）

## Promise 

​	是一个用来存放数据的对象	

​	他的特殊的存储方法使得他可以存放异步调用的数据

​	用于解决回调函数实现异步时的会回调地狱

### 创建 

​	通过构造函数 new Promise() 创建一个Promise实例

​	必须为构造函数添加一个回调函数作为参数（通过这个回调函数的参数来存放异步数据）

​	回调函数参数 ： 一般写为 ： resolve 和reject。两个参数都是一个函数

​	resolve 将会在程序正常运行时向Promise存放数据，reject将会在程序出错时向Promise存放数据

### 读取 

​	实例方法 ：

​	then()

​		两个参数 ： 都是回调函数，第一个参数可以用于读取resolve存放的数据，可以写入处理正常运行数据的代码；第二个参数可以读取reject存放的数据或者代码异常数据，可以写入处理异常运行数据的代码

​	catch() :

​		一个参数（回调函数），会在读取reject存放或者代码出错时（即Promise被拒接时）执行

​		专门处理Promise异常

​		相当于then()，只不过第一个参数为null

​	finally() : 

​		无论是正常存储数据还是出现异常，finally都会执行

​		finally的回调函数中，不会接受存放在实例中的数据。

​		用于编写一些无论是否成功都要执行的代码

### 两个隐藏属性 

​	PromiseResult ：存放数据

​	PromsieState  ：描述Promise的三个状态

​			pending :（数据正在存储进行中）

​			fulfilled :  (完成) 通过resolve存放数据时

​			rejected : （拒绝，出错）通过reject存放数据时

​		PromiseState只允许修改一次，之后无法进行修改

### 执行流程

​	首先通过构造函数创建一个Promise实例，实例的PromiseState将会设置为pending

​	当使用resolve存放数据时，PromiseState将会被设置为fulfilled

​	当使用reject存放数据或者代码出错时，PromiseState将被设置为rejected

​	当调用实例方法then时，会根据PromiseState的状态进行调用回调函数，fulfilled将调用第一个回调函数，rejected将

会调用第二个回调函数

### 链式调用

​	基础 ：

​		then、catch、finally三个方法调用时，会返回一个新的Promise对象，并将返回值存放到新Promise对象中（finally并不会）。

​	省略 ：

​		在链式调用中，如果当前的then或catch在读取上一个Promsie的存放的数据时（正常返回或异常信息），如果没有成功读到，将会直接跳过这个读取，转而进行下一个读取。

​	catch读错 ：

​		在链式调用中，catch只会读取他之前的错误，他后面的错误包括他本身的错误是不在这个catch读取范围内的，只能通过后面的catch读取

### Promsie的静态方法 

​	Promise.resolve() : 创建一个立即完成的Promise ，参数就是存放数据

​		相当与 ： new Promise((resolve,reject) => { resolve() })

​	Promise.reject() : 创建一个立即拒接的Promise ，功能与Promise.resolve一致

​	Promise.all() ： 

​		参数是一个迭代器（数组...），会返回一个数组，里面存放了参数迭代器中所有的Promise的运行结果。

​		其中当有一个Promise 是拒接的，将会抛出错误，一错全没

​	Promise.allsettled() ：

​		参数是一个迭代器（数组...），会返回一个对象数组，无论是否成功，Promise的状态和执行结果都存放在对象汇总

​	Promise.race() ：

​		参数是一个迭代器（数组...），所有Promise会一起执行，并返回一个最快执行的Promise数据

​	Promise.any() ：

​		参数是一个迭代器（数组...），所有Promise会一起执行，并返回一个最快执行并完成的Promise数据

新知识

​	throw new Error() : 自定义一个异常情况，可以传递参数来当做异常信息